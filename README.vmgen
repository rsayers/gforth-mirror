Vmgen generates much of the code for efficient virtual machine (VM)
interpreters from simple descriptions of the VM instructions.  It
generates code for executing VM instructions (with optional tracing),
for generating VM code, for disassembling VM code, and for profiling
VM instruction sequences.  A VM instruction description looks like
this:

add  ( i1 i2 -- i )
i = i1+i2;

Vmgen supports several techniques for writing efficient interpreters:
virtual machine interpreters, threaded code, combining VM instructions
into superinstructions, keeping the top-of-stack in a register,
scheduling the dispatch of the next VM instruction, and a couple of
minor optimizations.  Interpreters created with vmgen usually are
faster than competing interpreters and are typically only a factor of
2-10 slower than the code generateed by native-code compilers.

Vmgen has special support for stack-based VMs (but it can also be
used to advantage when implementing a register-based VM).

The main shortcoming in the current release is the lack of a user
manual; however, there is a paper describing vmgen's operation (at
http://www.complang.tuwien.ac.at/anton/vmgen/), and there is a simple,
working and somewhat commented example of using vmgen.

There are two versions of the example: in directory vmgen-ex you find
a version using many casts; in directory vmgen-ex2 you find a version
using unions instead of casts.

The current release requires GCC both for building and for compiling
the resulting interpreters (threaded code cannot be implemented in
ANSI C).

If you have bugs to report, suggestions to make, questions, or any
other feedback, mail me (anton@mips.complang.tuwien.ac.at).

You can find vmgen at http://www.complang.tuwien.ac.at/anton/vmgen/.

Vmgen is currently distributed with Gforth (because it needs Gforth to
run, and Gforth needs it to build), and is installed together with
Gforth (read INSTALL for instructions).  

Note that future versions of vmgen will probably require small changes
in programs written for the present version (e.g., requiring a few
additional macro definitions).
